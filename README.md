# CargoCompany
## Homework
- есть сущность Груз (Cargo): number, вес + еще какие-нибудь поля
- есть User: firstName, lastName, возраст
- есть три типа вагонов
- есть пассажирский вагон определенное количество мест и туда можно добавлять людей (User)с билетами на соответствующие места
- есть грузовой вагон: с грузоподъемностью и возможностью грузить Cargo в пределах грузоподъемности
- есть локомотив: машинист User (с возрастом > 18 лет и наличием лицензии)
- есть поезд: номер + сцепленные вагоны (реализовать самостоятельно связным списком не используя LinkedList)
- требуется дизайн классов + тесты, логи, maven
- использовать коллекции
- дедлайн до 27.09
### Cargo
У нас есть сущность груз (`Cargo`) у него есть вес.
Понятно, что когда вы слышите “сущность груз” вам нужно подумать, какие поля `Immutable`, `equals()` и `hashCode()`, и, наверное, придумать какие-то `id`. Постарайтесь включить фантазию, как будто вы пишете проект. Представьте, у вас родилась идея. Вы хотите сделать систему управления, я пока про груз говорю, грузами какими-то. Понятное дело, что там должно быть, какой-то `number`, что-то еще. Какой-то минимальный набор полей. Может `id`, может `id` и не надо раз есть `number`. Но главное, что у нас есть вес. Плюс ещё какие-нибудь поля. Сразу напишу, чтобы был простор для фантазии.
// есть сущность Груз (Cargo): number, вес + еще какие-нибудь поля
### User
Есть `User`: у него `firstName`, `lastName`, у него есть возраст и пока оставим. `User` — это может быть просто `User`, а также могут быть какие-то наследники этого `User`. `User` плюс билет — это уже пассажир. Подумайте, какие-нибудь решения. Тут нет однозначного хорошего решения.
// есть User: firstName, lastName, возраст
### Пассажирский вагон
Есть пассажирский вагон, где есть определенное количество мест и туда можно добавлять людей с билетами на соответствующее место.
// есть три типа вагонов
// есть пассажирский вагонЖ определенное количество мест и туда можно добавлять людей (User) с билетами на соответствующие места
### Грузовой вагон
Есть грузовой вагон, везде можно поля добавлять, которые посчитаете нужным, с грузоподъемностью и возможностью грузить `Cargo` в пределах грузоподъемности.
// есть грузовой вагон: с грузоподъемностью и возможностью грузить Cargo в пределах грузоподъемности
### Локомотив
Есть локомотив: машинист User (с возрастом больше 18 лет и наличием лицензии)
// есть локомотив: машинист User (с возрастом > 18 лет и наличием лицензии)
### Поезд
Есть поезд: номер поезда плюс сцепленные вагоны (реализовать самостоятельно связным списком). Просто у вас есть `head` у поезда, внутри где-то сидит и дальше мы туда цепляем вагончики. Т.е. не используя `LinkedList`. Не использовать не потому, чтобы вы понапрягались. В принципе, `class Node<E>` и есть поезд. В него нужно больше характерных для нашего поезда вещей добавить.
// есть поезд: номер + сцепленные вагоны (реализовать самостоятельно связным списком не используя LinkedList)
### Общие замечания
Это нужно все задизайнить. Здесь что у нас? Понятное дело, наследование будет. Это бизнес-домен. Здесь я прямо говорю, что бывают три типа вагонов: локомотив, пассажирский, грузовой. Нам нужно собрать поезд из всего этого безобразия.
Требуется дизайн классов, плюс тесты, логи, `maven`. А логгирование тут вопрос ещё нужно или нет. Потому, что в доменных сущностях может и не надо. Внутри доменных классов логгировать не надо особо. Логи по типу: поезд собран, добавлен такой-то пассажир. Хотя это не сильно пишут, но я не буду говорить на это, что это плохо. Понятно, тут валидацию билетов можно сделать.
Использовать коллекции.
// требуется дизайн классов + тесты, логи, maven
// использовать коллекции
Получается мы поезд собрали и дальше с ним можем работать. Я помню, в прошлой школе, там немножко интересно подошли к этой задаче. Там были методы, которые писали на `console` чух-чух. Это уже излишества, поезд не будет ездить. Просто система управления поездами. Предполагается какое-то практическое применение. Кто-то заходит и говорит. Представляете себе, графический интерфейс, если это развить. Нажимаешь создать поезд. Номер генерируется. Задаешь номер, всё - поезд есть. Он пока ещё там не полный. Вагонов каких-то посмотрел. Где какие свободны. Потом в вагоны грузы подобавлял. И всё это должно как-то работать. Вы можете добавить каких-то своих сервисов, если хотите. Но по сути, это все может самодостаточно сделаться.
Давайте мы сделаем у этого `deadline`. Ну давайте две недели. До двадцать седьмого сентября давайте, чтобы было двое выходных. 
// дедлайн до 27.09
Если что там у кого сложности возникнут, то качество `first.` Если кому-то мало будет времени, то вы пишите, говорите, что я не успеваю качественно сделать. Будем `deadline` двигать. Я ожидаю прям очень хорошее качество. Каждая штука должна быть продумана. Тут не задача наколбасить. Мы с вами много говорили уже. Вы смотрели уже много всякого кода. Надо постараться сделать все на максимально хорошем качестве. Если я вижу кусок кода, который не покрыт тестами. Я спрошу, почему это не покрыто тестами. Т.е. это будет нехорошо. Не то, что вам нужно треснуть и сделать то качество, которое вы не можете. Просто хорошо подумайте. Не спешите. Я не очень обрадуюсь, когда увижу код, который плохо отформатирован. Очень мало тестов. Это не такая задача, где нужно сказать, короче, вот я показал, как я умею тесты писать на одном примере. Я хочу увидеть как бы вы этот код сделали для проекта. Для проекта надо написать все тесты, которые только можно. Максимально качественно. Тесты, понятное дело, могут быть и с `Mockito`, и просто тесты. С `Mockito` тут, может быть, будет поменьше тестов. Потому что здесь именно доменные сущности. Никто не запрещает эти поезда собирать, смотреть, что-то с ними делать.
Я почему даю много времени. Не потому, что задача сложная. Сейчас у многих возникнет вопрос, что-то вроде как-то не очень сложно, а времени много. Попробуйте начните писать. Там на деле не так уж там и просто. Всё с тестами, с логгированием.
Главное задизайнить именно сущности, а сервисы здесь не требуются. Если кому-то хочется сервис, типа, `createTrain`, непонятно, что туда передать. `createTrain` получит уже какой-то собранный поезд. Или `add` вагон к `train`. Можно такие написать. Если кому-то хочется, напишите, но это не требуется.
### Уточнение по дизайну классов
#### Вопрос по дизайну. Насколько сложными должны быть эти классы изначально как сущности? Должны ли они сами контролировать себя? Или это должен какой-нибудь сервис делать? Надо ли их насыщать вспомогательными методами различными?
Смотрите, в задаче указано, сейчас я расскажу. Поля у них какие-нибудь должны быть. Ну чтобы было интереснее. За это я, конечно, не смогу вам ничего предъявить, если вы сделаете минимально-необходимые поля. Но вы просто представьте, что вы решили делать `start-up` для управления грузоперевозками. Поездами и прочим. Вы еще пока не знаете. У вас нету клиентов никаких. Просто представьте, что вот у вас есть поезда, пассажиры, люди и прочие. Вам нужно сделать некий прототип. Поэтому насыщать нужно так, чтобы было интересно.
Ну там что у поезда есть? У поезда кроме вагонов есть какой-то номер. Да и все. Потому что поезд — это собрание вагонов.  Груз у него может быть, ну там без фанатизма, т.е. это тоже номер, какие-то детали и прочее.
Да лучше писать классы, чтобы они себя контролировали. Сервис здесь необязателен. Потому что здесь как раз-таки идея показать, что классы — это такая матрешка будет. Матрешка, тут посмотрите, как начнете писать. Не понадобится особо сервисов. Лучше, чтобы классы минимально себя контролировали. Здесь сама структура данных сама по себе такая сама по себе, которая решит сама все вопросы.
Т.е., например, я добавляю в вагон грузовой груз, ну пусть вагон бросит ошибку, проверит. Было бы глупо если бы какой-то сервис брал у вагона спрашивал, а сколько у тебя груза уже есть? А зачем, а что да как? Влазит/ не влазит?
Видно, да? Какой подход лучше. Потому что вдруг кто-то начнет сам возьмет вагон, сам начнет в него пихать грузы мимо вашего сервиса.
Здесь это два как бы разных подхода. И такой, и такой в чем-то бы сошёл. Но вообще валидацию лучше повесить на каких-то методах. Лучше, чтобы они были немножко `defensive`.
По наполнению сильно не усердствуйте, без фанатизма, но чтобы было интересно.
Ну тесты, конечно, нужны.
Я себе представляю это как?
Я себе представляю, что это просто метод `main`, который будет. Ну вот можно даже начать от обратного. Сказать
`Train train = new Train("1224452324");`
Я не подсказываю, просто пишу. Очевидно, что в `Locomotive` должен быть машинист. 
`train.addCarriage(new Locomotive(new Driver()));`
Потом добавить `addCarriage`, `new PassengerCarriage`
`train.addCarriate(new PassengerCarriage);`
Потом добавить грузовой вагон.
`CargoCarriage cc = new CargoCarriage;`
`cc.addCargo()`
 Понятно, что `CargoCarriage` должен проверить вмещается этот груз и этот `CargoCarriage` знает, как этот `Cargo` там правильно хранить. Иначе с этих классов толку никакого нет.
Тут может быть по-разному. Можно либо `Exception` бросить. Тут опять же нет правильного варианта. Либо может вернуть результат. Сказать, что `addCargo()` и мы вернули `boolean`, например. `Boolean` означает влезло/ не влезло. Если не влезло, то мы можем как делать?
Можно у `train` метод сделать, у `train`, наверно, нелогично. Можно пройтись по всем `Carriage`, найти все `CargoCarriage` и по цепочке там, по любой логике попробовать нагрузить в них.
Сказать, что вот первый вагон, влазит лишний груз или не влазит. Не влазит, плохо. Давайте в следующий грузовой вагон его попробуем загрузить. Либо как-то по-другому поискать. Да, ну вот, в принципе, такая задачка.
Здесь получается больше акцент на дизайн классов и немножко на коллекции.
Если кто-то думает, что здесь есть скрытый смысл, подвох. Нет, оно как есть, так есть. Ничего такого сверхъестественного. И время я дал больше, чтобы вам можно было кое-что читать, смотреть. Чтобы это было не полный загруз, потому что задача какая-то сложная. Там типа предпоследняя. Нет эта задача не сложная. Её можно сделать за пятнадцать минут, но может быть с тестами, еще пару часов потратить на тесты, чтобы были красивые тесты. Чтобы проверяли, что все хорошо, грузится/ не грузится, пассажиры с билетами садятся, а без билетов не садятся. `Driver` там такой-то, `Driver` сякой. Ничего такого сверхъестественного.
И опять же, как вам будет угодно. Если кому-то сильно захотелось сделать через сервисы. Сделать просто классы с `getters&setters`, ну это не очень хорошо. Они тогда будут `mutable` все. Они тогда будут просто глупые контейнеры. Они потеряют свою `consistency`. Потеряют свою целостность. Получается перегруженный вагон будет какой-то. Без валидации. Локомотив с каким-то драйвером, который не драйвер на самом деле.
И тут еще сказать плюс один, чтобы сделать через умные классы. Помните, я рассказывал, что код должен немного выглядеть как бизнес-требования, как текст. Желательно, чтобы кода было мало.
Если я открываю и вижу, что здесь какой-то метод сложный, что он что-то короче грузит куда-то. У вас так может и получиться, что ваш сервис сойдется в какой-то адский код, который делает что-то такое. На самом деле вот если написать более или менее классы. Не сильно умные, но с минимальной защитой, с минимальной логикой. То сама бизнес-логика, её очень мало будет. Как я вот здесь писал. Взял `train`, собрал, грузы загрузил, заходишь в методы этого `train`, методы все простые. Они дергают какие-то другие методы, у `Cargo`, у `CargoCarriage`, у пассажира, у драйвера. Все как бы друг друга дергает. Все вроде бы связано, закрыто, протестировано. Получается кода мало, все красиво, все понятно. `Maintainability` на уровне. А если сделать это в сервисе, я просто представляю там, что в этот сервис можно передать. Метод у сервиса, загрузите мне этот `Cargo` в такой-то `CargoCarriage`. И он там проверяет, делает. А потом использование сложно. Вот у меня есть `CargoCarriage`, как мне понять, что `Cargo` только через `Service` надо грузить. Ну сложно, да? Понимаете.
Поэтому поля на свое усмотрение. Не надо бояться. Нет никакого подвоха здесь. Так задачка простая. Как продолжение предыдущей, только немного больше коллекций, больше всего. Если кто-то знает `lambda`, `streams`, то делайте с `lambda` и со `streams`. Ну интерфейсы, про интерфейсы мы уже говорили. Если надо, интерфейсы здесь могут и не понадобиться. Потому что здесь можно все на доменных классах сделать. А для доменных классов интерфейсы обычно не пишутся.
Понятно, в целом? Надеюсь, что понятно.
Вообразите, что вы пишете какой-то проект, `start-up`. Вы решили, а давайте я железной дороге буду продавать. У них там поезда какие-то, можно в файлы потом сохранять все, в базу данных это все сохраняется. Но там хочется это как-то контролировать, паровозики эти подоставать, посмотреть что там куда нагружено. Посмотреть, что куда грузится. Короче такая идея.
